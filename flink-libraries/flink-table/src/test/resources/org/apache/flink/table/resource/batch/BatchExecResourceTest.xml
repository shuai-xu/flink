<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="testAggregateWithJoin[ALL]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[59], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[800], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[150], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[150], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[800], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=35, preferManagedMem=71, maxManagedMem=470}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAggregateWithJoin[NONE]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAggregateWithJoin[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[150], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[18], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testConfigSourceParallelism[ALL]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[20], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testConfigSourceParallelism[NONE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[100], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[100], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[100], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testConfigSourceParallelism[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testEnvParallelism[ALL]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[59], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[800], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[150], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[150], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[800], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[800], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=35, preferManagedMem=71, maxManagedMem=470}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testEnvParallelism[NONE]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[73], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[73], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[73], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[73], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testEnvParallelism[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[select c.c_name, sum(l.l_quantity) from customer c, orders o, lineitem l where o.o_orderkey in (  select l_orderkey from lineitem group by l_orderkey having sum(l_quantity) > 300) and c.c_custkey = o.o_custkey and o.o_orderkey = l.l_orderkey group by c.c_name]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[8.155406266951476E8], rowcount=[1.4061045287847374E7], isMerge=[false], groupBy=[c_name], select=[c_name, SUM(l_quantity) AS EXPR$1])
+- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709000005E7], distribution=[hash[c_name]])
   +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709000005E7], select=[c_name, l_quantity])
      +- HashJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[7.500000000000006E8], rowcount=[5.999989709000005E7], where=[=(o_orderkey, l_orderkey)], join=[c_name, o_orderkey, l_orderkey, l_quantity], joinType=[InnerJoin], build=[left])
         :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_orderkey]])
         :  +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5000000000000013E7], select=[c_name, o_orderkey])
         :     +- HashJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[4.800000000000004E8], rowcount=[1.5000000000000013E7], where=[=(c_custkey, o_custkey)], join=[c_custkey, c_name, o_orderkey, o_custkey], joinType=[InnerJoin], build=[right])
         :        :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E8], distribution=[hash[c_custkey]])
         :        :  +- Calc(partition=[150], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], select=[c_custkey, c_name])
         :        :     +- TableSourceScan(partition=[150], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E8], table=[[default_catalog, default_db, customer]], fields=[c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment])
         :        +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5000000000000013E7], distribution=[hash[o_custkey]])
         :           +- HashSemiJoin(partition=[73], shuffleCount=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[3.6E8], rowcount=[1.5000000000000013E7], where=[=(o_orderkey, l_orderkey)], join=[o_orderkey, o_custkey], joinType=[LeftSemiJoin], build=[right])
         :              :- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.5E9], distribution=[hash[o_orderkey]])
         :              :  +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], select=[o_orderkey, o_custkey])
         :              :     +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E9], table=[[default_catalog, default_db, orders]], fields=[o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment])
         :              +- Calc(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.5E7], select=[l_orderkey], where=[>($f1, 300)])
         :                 +- HashAggregate(partition=[73], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[6.0E10], rowcount=[1.5E9], isMerge=[false], groupBy=[l_orderkey], select=[l_orderkey, SUM(l_quantity) AS $f1])
         :                    +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
         :                       +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
         :                          +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
         +- Exchange(partition=[-1], memCost=[0.0], rowcount=[5.999989709E9], distribution=[hash[l_orderkey]])
            +- Calc(partition=[1000], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], select=[l_orderkey, l_quantity])
               +- TableSourceScan(partition=[1000], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testLimitPushDown[ALL]">
    <Resource name="sql">
      <![CDATA[select * from lineitem limit 1]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[true])
+- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
   +- Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[false])
      +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testLimitPushDown[NONE]">
    <Resource name="sql">
      <![CDATA[select * from lineitem limit 1]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[true])
+- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
   +- Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[false])
      +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testLimitPushDown[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[select * from lineitem limit 1]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[true])
+- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
   +- Limit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], offset=[0], limit=[1], global=[false])
      +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.999989709E9], table=[[default_catalog, default_db, lineitem]], fields=[l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRangePartition[ALL]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM Table5 where d < 100 order by e]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Sort(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=53, preferManagedMem=57, maxManagedMem=57}], memCost=[440.0], rowcount=[5.0], orderBy=[e ASC])
+- Exchange(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], distribution=[range[e ASC]])
   +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], select=[d, e, f, g, h], where=[<(d, 100)])
      +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRangePartition[NONE]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM Table5 where d < 100 order by e]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Sort(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=53, preferManagedMem=57, maxManagedMem=57}], memCost=[440.0], rowcount=[5.0], orderBy=[e ASC])
+- Exchange(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], distribution=[range[e ASC]])
   +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], select=[d, e, f, g, h], where=[<(d, 100)])
      +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRangePartition[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM Table5 where d < 100 order by e]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Sort(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=53, preferManagedMem=57, maxManagedMem=57}], memCost=[440.0], rowcount=[5.0], orderBy=[e ASC])
+- Exchange(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], distribution=[range[e ASC]])
   +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[5.0], select=[d, e, f, g, h], where=[<(d, 100)])
      +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSortLimit[ALL]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[20], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSourcePartitionMaxNum[NONE]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM SmallTable3]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSortLimit[NONE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSortLimit[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, c FROM SmallTable3 group by c order by c limit 2]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0], select=[sum_a, c])
+- SortLimit(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[true])
   +- Exchange(partition=[1], memCost=[0.0], rowcount=[1.0], distribution=[single])
      +- SortLimit(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[16.0], rowcount=[1.0], orderBy=[c ASC], offset=[0], limit=[2], global=[false])
         +- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], isMerge=[true], groupBy=[c], select=[c, Final_SUM(sum$0) AS sum_a])
            +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.0], distribution=[hash[c]])
               +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0], groupBy=[c], select=[c, Partial_SUM(a) AS sum$0])
                  +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[c, a])
                     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSourcePartitionMaxNum[ALL]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM SmallTable3]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSourcePartitionMaxNum[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[SELECT * FROM SmallTable3]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSubsectionOptimization[ALL]">
    <Resource name="planAfter">
      <![CDATA[
[[IntermediateTable=_DataStreamTable_0]]
Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
+- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
   +- Exchange(partition=[18], memCost=[0.0], rowcount=[1.0])
      +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
         +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])
            +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSubsectionOptimization[NONE]">
    <Resource name="planAfter">
      <![CDATA[
[[IntermediateTable=_DataStreamTable_0]]
Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
+- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
   +- Exchange(partition=[18], memCost=[0.0], rowcount=[1.0])
      +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
         +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])
            +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnionQuery[NONE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, g FROM (SELECT a, b, c FROM SmallTable3 UNION ALL SELECT a, b, c FROM Table3), Table5 WHERE b = e group by g]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.7129264753527287], select=[sum_a, g])
+- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], isMerge=[true], groupBy=[g], select=[g, Final_SUM(sum$0) AS sum_a])
   +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.7129264753527287], distribution=[hash[g]])
      +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], groupBy=[g], select=[g, Partial_SUM(a) AS sum$0])
         +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[18.0], select=[g, a])
            +- HashJoin(partition=[1], shuffleCount=[1074], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[472560.0], rowcount=[18.0], where=[=(b, e)], join=[a, b, e, g], joinType=[InnerJoin], isBroadcast=[true], build=[right])
               :- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[110.0], select=[a, b])
               :  +- Union(partition=[-1], memCost=[0.0], rowcount=[110.0], all=[true], union=[a, b, c])
               :     :- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
               :     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[100.0], table=[[default_catalog, default_db, Table3]], fields=[a, b, c])
               +- Exchange(partition=[-1], memCost=[0.0], rowcount=[10.0], distribution=[broadcast])
                  +- Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[e, g])
                     +- TableSourceScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSubsectionOptimization[ONLY_SOURCE]">
    <Resource name="planAfter">
      <![CDATA[
[[IntermediateTable=_DataStreamTable_0]]
Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
+- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
   +- Exchange(partition=[18], memCost=[0.0], rowcount=[1.0])
      +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[52.0], rowcount=[1.0])
         +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])
            +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])

[[Sink]]
Sink(partition=[-1], memCost=[0.0], rowcount=[1.0])
+- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.0])
   +- HashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[1.0])
      +- Exchange(partition=[1], memCost=[0.0], rowcount=[20.0])
         +- LocalHashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[4.0], rowcount=[20.0])
            +- BoundedStreamScan(partition=[18], sourceRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1000.0])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnionQuery[ONLY_SOURCE]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, g FROM (SELECT a, b, c FROM SmallTable3 UNION ALL SELECT a, b, c FROM Table3), Table5 WHERE b = e group by g]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.7129264753527287], select=[sum_a, g])
+- HashAggregate(partition=[18], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], isMerge=[true], groupBy=[g], select=[g, Final_SUM(sum$0) AS sum_a])
   +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.7129264753527287], distribution=[hash[g]])
      +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=33, preferManagedMem=37, maxManagedMem=37}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], groupBy=[g], select=[g, Partial_SUM(a) AS sum$0])
         +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[18.0], select=[g, a])
            +- HashJoin(partition=[1], shuffleCount=[1074], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=43, preferManagedMem=47, maxManagedMem=47}], memCost=[472560.0], rowcount=[18.0], where=[=(b, e)], join=[a, b, e, g], joinType=[InnerJoin], isBroadcast=[true], build=[right])
               :- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[110.0], select=[a, b])
               :  +- Union(partition=[-1], memCost=[0.0], rowcount=[110.0], all=[true], union=[a, b, c])
               :     :- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
               :     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[100.0], table=[[default_catalog, default_db, Table3]], fields=[a, b, c])
               +- Exchange(partition=[-1], memCost=[0.0], rowcount=[10.0], distribution=[broadcast])
                  +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[e, g])
                     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnionQuery[ALL]">
    <Resource name="sql">
      <![CDATA[SELECT sum(a) as sum_a, g FROM (SELECT a, b, c FROM SmallTable3 UNION ALL SELECT a, b, c FROM Table3), Table5 WHERE b = e group by g]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[1.7129264753527287], select=[sum_a, g])
+- HashAggregate(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], isMerge=[true], groupBy=[g], select=[g, Final_SUM(sum$0) AS sum_a])
   +- Exchange(partition=[-1], memCost=[0.0], rowcount=[1.7129264753527287], distribution=[hash[g]])
      +- LocalHashAggregate(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[89.0721767183419], rowcount=[1.7129264753527287], groupBy=[g], select=[g, Partial_SUM(a) AS sum$0])
         +- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[18.0], select=[g, a])
            +- HashJoin(partition=[1], shuffleCount=[1074], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=32, preferManagedMem=32, maxManagedMem=470}], memCost=[472560.0], rowcount=[18.0], where=[=(b, e)], join=[a, b, e, g], joinType=[InnerJoin], isBroadcast=[true], build=[right])
               :- Calc(partition=[1], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[110.0], select=[a, b])
               :  +- Union(partition=[-1], memCost=[0.0], rowcount=[110.0], all=[true], union=[a, b, c])
               :     :- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, SmallTable3]], fields=[a, b, c])
               :     +- TableSourceScan(partition=[1], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[100.0], table=[[default_catalog, default_db, Table3]], fields=[a, b, c])
               +- Exchange(partition=[-1], memCost=[0.0], rowcount=[10.0], distribution=[broadcast])
                  +- Calc(partition=[20], resource=[RelResource{cpu=0.3, heapMem=46, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], select=[e, g])
                     +- TableSourceScan(partition=[20], sourceRes=[Resource: {cpu=0.3, heap=52}], conversionRes=[Resource: {cpu=0.3, heap=46}], resource=[RelResource{cpu=0.3, heapMem=98, reservedManagedMem=0, preferManagedMem=0, maxManagedMem=0}], memCost=[0.0], rowcount=[10.0], table=[[default_catalog, default_db, Table5]], fields=[d, e, f, g, h])
]]>
    </Resource>
  </TestCase>
</Root>
