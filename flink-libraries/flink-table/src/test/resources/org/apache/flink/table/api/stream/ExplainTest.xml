<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="testFilter">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalFilter(condition=[=(MOD($0, 2), 0)])
+- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[a, b], where=[=(MOD(a, 2), 0)])
+- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(where: ((a MOD 2) = 0), select: (a, b))
			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiLevelViewForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[LIKE($2, '%hello%')])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T3]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T3]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%hello%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[3])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecUnion(all=[true], union=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :  +- Reused(reference_id=[1])
      +- StreamExecCalc(select=[num, id], where=[LIKE(text, '%world%')], updateAsRetraction=[true], accMode=[Acc])
         +- Reused(reference_id=[2])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[3])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[3])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(where: (text LIKE '%hello%'), select: (id, num, text))
			ship_strategy : FORWARD

			 : Operator
				content : SinkConversion to Row
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (num, id))
					ship_strategy : FORWARD

					 : Operator
						content : Calc(where: (text LIKE '%world%'), select: (num, id))
						ship_strategy : FORWARD

						 : Operator
							content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
							ship_strategy : HASH

							 : Operator
								content : Calc(where: (num < 4), select: (num, cnt))
								ship_strategy : FORWARD

								 : Operator
									content : SinkConversion to Tuple2
									ship_strategy : FORWARD

									 : Operator
										content : Map
										ship_strategy : FORWARD

										 : Operator
											content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
											ship_strategy : FORWARD

											 : Data Sink
												content : Sink: TestingAppendTableSink
												ship_strategy : FORWARD

												 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

													 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							 : Operator
								content : GroupAggregate(select: (MIN(a) AS TMP_1))
								ship_strategy : GLOBAL

								 : Operator
									content : Calc(select: (TMP_1 AS total_min))
									ship_strategy : FORWARD

									 : Operator
										content : SinkConversion to Tuple2
										ship_strategy : FORWARD

										 : Operator
											content : Map
											ship_strategy : FORWARD

											 : Data Sink
												content : Sink: TestingUpsertTableSink(keys=())
												ship_strategy : FORWARD

												 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							 : Operator
								content : GroupAggregate(select: (MIN(a) AS TMP_1))
								ship_strategy : GLOBAL

								 : Operator
									content : Calc(select: (TMP_1 AS total_min))
									ship_strategy : FORWARD

									 : Operator
										content : SinkConversion to Tuple2
										ship_strategy : FORWARD

										 : Operator
											content : Map
											ship_strategy : FORWARD

											 : Data Sink
												content : Sink: TestingUpsertTableSink(keys=())
												ship_strategy : FORWARD

												 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion3">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(a=[$0])
+- LogicalUnion(all=[true])
   :- LogicalTableScan(table=[[builtin, default, t1]])
   +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])
:- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
:  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- Reused(reference_id=[2])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[a], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[2])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
						ship_strategy : FORWARD

						 : Operator
							content : Calc(select: (a))
							ship_strategy : FORWARD

							 : Operator
								content : GroupAggregate(select: (SUM(a) AS TMP_0))
								ship_strategy : GLOBAL

								 : Operator
									content : Calc(select: (TMP_0 AS total_sum))
									ship_strategy : FORWARD

									 : Operator
										content : GroupAggregate(select: (MIN(a) AS TMP_1))
										ship_strategy : GLOBAL

										 : Operator
											content : Calc(select: (TMP_1 AS total_min))
											ship_strategy : FORWARD

											 : Operator
												content : SinkConversion to Tuple2
												ship_strategy : FORWARD

												 : Operator
													content : Map
													ship_strategy : FORWARD

													 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

														 : Data Sink
															content : Sink: TestingRetractTableSink
															ship_strategy : FORWARD

															 : Data Sink
																content : Sink: TestingUpsertTableSink(keys=())
																ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion4">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0])
+- LogicalUnion(all=[true])
   :- LogicalProject(a=[$0], c=[$2])
   :  +- LogicalTableScan(table=[[builtin, default, t1]])
   +- LogicalProject(d=[$0], f=[$2])
      +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[a], updateAsRetraction=[false], accMode=[Acc], reuse_id=[1])
:- StreamExecCalc(select=[a], updateAsRetraction=[false], accMode=[Acc])
:  +- StreamExecCalc(select=[a, c], updateAsRetraction=[true], accMode=[Acc])
:     +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecCalc(select=[d], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecCalc(select=[d, f], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[a], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- Reused(reference_id=[1])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[2])

StreamExecSink(fields=[total_min], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[2])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a, c))
			ship_strategy : FORWARD

			 : Operator
				content : Calc(select: (a))
				ship_strategy : FORWARD

				 : Operator
					content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
					ship_strategy : FORWARD

					 : Operator
						content : Calc(select: (d, f))
						ship_strategy : FORWARD

						 : Operator
							content : Calc(select: (d))
							ship_strategy : FORWARD

							 : Operator
								content : SinkConversion to Row
								ship_strategy : FORWARD

								 : Operator
									content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
									ship_strategy : FORWARD

									 : Operator
										content : Calc(select: (a))
										ship_strategy : FORWARD

										 : Operator
											content : GroupAggregate(select: (SUM(a) AS TMP_0))
											ship_strategy : GLOBAL

											 : Operator
												content : Calc(select: (TMP_0 AS total_sum))
												ship_strategy : FORWARD

												 : Operator
													content : SinkConversion to Tuple2
													ship_strategy : FORWARD

													 : Operator
														content : Map
														ship_strategy : FORWARD

														 : Operator
															content : GroupAggregate(select: (MIN(a) AS TMP_1))
															ship_strategy : GLOBAL

															 : Operator
																content : Calc(select: (TMP_1 AS total_min))
																ship_strategy : FORWARD

																 : Data Sink
																	content : Sink: TestingAppendTableSink
																	ship_strategy : FORWARD

																	 : Data Sink
																		content : Sink: TestingRetractTableSink
																		ship_strategy : FORWARD

																		 : Data Sink
																			content : Sink: TestingUpsertTableSink(keys=())
																			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion5">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :  :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
   :     +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
						ship_strategy : FORWARD

						 : Operator
							content : Calc(select: (a))
							ship_strategy : FORWARD

							 : Operator
								content : GroupAggregate(select: (SUM(a) AS TMP_0))
								ship_strategy : GLOBAL

								 : Operator
									content : Calc(select: (TMP_0 AS total_sum))
									ship_strategy : FORWARD

									 : Operator
										content : GroupAggregate(select: (MIN(a) AS TMP_1))
										ship_strategy : GLOBAL

										 : Operator
											content : Calc(select: (TMP_1 AS total_min))
											ship_strategy : FORWARD

											 : Operator
												content : SinkConversion to Tuple2
												ship_strategy : FORWARD

												 : Operator
													content : Map
													ship_strategy : FORWARD

													 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

														 : Data Sink
															content : Sink: TestingRetractTableSink
															ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testRetractAndUpsertSink">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					 : Operator
						content : Calc(where: (num < 4), select: (num, cnt))
						ship_strategy : FORWARD

						 : Operator
							content : SinkConversion to Tuple2
							ship_strategy : FORWARD

							 : Operator
								content : Map
								ship_strategy : FORWARD

								 : Operator
									content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

										 : Data Sink
											content : Sink: TestingUpsertTableSink(keys=())
											ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testRetractAndUpsertSinkForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T1]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T1]])

== Optimized Logical Plan ==
StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				 : Operator
					content : Calc(where: (num < 4), select: (num, cnt))
					ship_strategy : FORWARD

					 : Operator
						content : SinkConversion to Tuple2
						ship_strategy : FORWARD

						 : Operator
							content : Map
							ship_strategy : FORWARD

							 : Operator
								content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
								ship_strategy : FORWARD

								 : Data Sink
									content : Sink: TestingRetractTableSink
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=())
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSharedUnionNode">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[LIKE($2, '%hello%')])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[>=($1, 5)])
   +- LogicalTableScan(table=[[builtin, default, T3]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T4]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T4]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%hello%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%world%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[3])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecUnion(all=[true], union=[id, num, text], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[id, num, text], where=[>=(num, 5)], updateAsRetraction=[true], accMode=[Acc])
   :  +- Reused(reference_id=[1])
   +- StreamExecCalc(select=[id, num, text], where=[>=(num, 5)], updateAsRetraction=[true], accMode=[Acc])
      +- Reused(reference_id=[3])

StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[4])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecUnion(all=[true], union=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :  +- Reused(reference_id=[1])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- Reused(reference_id=[3])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[4])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[4])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(where: (text LIKE '%hello%'), select: (id, num, text))
			ship_strategy : FORWARD

			 : Operator
				content : SinkConversion to Row
				ship_strategy : FORWARD

				 : Operator
					content : Calc(where: (num >= 5), select: (id, num, text))
					ship_strategy : FORWARD

					 : Operator
						content : Calc(where: (text LIKE '%world%'), select: (id, num, text))
						ship_strategy : FORWARD

						 : Operator
							content : Calc(where: (num >= 5), select: (id, num, text))
							ship_strategy : FORWARD

							 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								 : Operator
									content : Map
									ship_strategy : FORWARD

									 : Operator
										content : Calc(select: (num, id))
										ship_strategy : FORWARD

										 : Operator
											content : Calc(select: (num, id))
											ship_strategy : FORWARD

											 : Operator
												content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
												ship_strategy : HASH

												 : Operator
													content : Calc(where: (num < 4), select: (num, cnt))
													ship_strategy : FORWARD

													 : Operator
														content : SinkConversion to Tuple2
														ship_strategy : FORWARD

														 : Operator
															content : Map
															ship_strategy : FORWARD

															 : Operator
																content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
																ship_strategy : FORWARD

																 : Data Sink
																	content : Sink: TestingAppendTableSink
																	ship_strategy : FORWARD

																	 : Data Sink
																		content : Sink: TestingRetractTableSink
																		ship_strategy : FORWARD

																		 : Data Sink
																			content : Sink: TestingRetractTableSink
																			ship_strategy : FORWARD

																			 : Data Sink
																				content : Sink: TestingUpsertTableSink(keys=())
																				ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSingleSinkSplitOnUnion1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
            :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
            :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
               +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								 : Operator
									content : Map
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSingleSinkSplitOnUnion2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
            :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
            :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
               +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								 : Operator
									content : Map
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUdtf">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalCorrelate(correlation=[$cor2], joinType=[inner], requiredColumns=[{}])
:- LogicalFilter(condition=[=($0, $6)])
:  +- LogicalJoin(condition=[true], joinType=[inner])
:     :- LogicalFilter(condition=[=($1, $4)])
:     :  +- LogicalJoin(condition=[true], joinType=[inner])
:     :     :- LogicalTableScan(table=[[builtin, default, t1]])
:     :     +- LogicalTableScan(table=[[builtin, default, t2]])
:     +- LogicalTableScan(table=[[builtin, default, t3]])
+- LogicalTableFunctionScan(invocation=[org$apache$flink$table$util$TableFunc1$667277b3d034024d7ed13cf6016a032c($5)], rowType=[RecordType(VARCHAR(65536) f1)], elementType=[class [Ljava.lang.Object;])

== Optimized Logical Plan ==
StreamExecSink(fields=[a, b, c, d, e, f, i, j, k, l, m, f1], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCorrelate(invocation=[org$apache$flink$table$util$TableFunc1$667277b3d034024d7ed13cf6016a032c($5)], correlate=[table(TableFunc1(f))], select=[a,b,c,d,e,f,i,j,k,l,m,f1], rowType=[RecordType(INTEGER a, BIGINT b, VARCHAR(65536) c, INTEGER d, BIGINT e, VARCHAR(65536) f, INTEGER i, BIGINT j, INTEGER k, VARCHAR(65536) l, BIGINT m, VARCHAR(65536) f1)], joinType=[INNER], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecJoin(where=[=(a, i)], join=[a, b, c, d, e, f, i, j, k, l, m], joinType=[InnerJoin], updateAsRetraction=[false], accMode=[Acc])
      :- StreamExecExchange(distribution=[hash[a]], updateAsRetraction=[true], accMode=[Acc])
      :  +- StreamExecJoin(where=[=(b, e)], join=[a, b, c, d, e, f], joinType=[InnerJoin], updateAsRetraction=[true], accMode=[Acc])
      :     :- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[true], accMode=[Acc])
      :     :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
      :     +- StreamExecExchange(distribution=[hash[e]], updateAsRetraction=[true], accMode=[Acc])
      :        +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[i]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
			ship_strategy : FORWARD

			 : Operator
				content : InnerJoin(where: (=(b, e)), join: (a, b, c, d, e, f))
				ship_strategy : HASH

				 : Operator
					content : SourceConversion(table:[builtin, default, t3], fields:(i, j, k, l, m))
					ship_strategy : FORWARD

					 : Operator
						content : InnerJoin(where: (=(a, i)), join: (a, b, c, d, e, f, i, j, k, l, m))
						ship_strategy : HASH

						 : Operator
							content : correlate: table(TableFunc1(f)), select: a,b,c,d,e,f,i,j,k,l,m,f1
							ship_strategy : FORWARD

							 : Data Sink
								content : Sink: csv sink: file
								ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnion">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalUnion(all=[true])
:- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
+- LogicalTableScan(table=[[builtin, default, _DataStreamTable_1]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[count, word])
:- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]])
+- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_1]])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(count, word))
		ship_strategy : FORWARD

		 : Operator
			content : SourceConversion(table:[builtin, default, _DataStreamTable_1], fields:(count, word))
			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnionAggWithDifferentGroupings">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalUnion(all=[true])
:- LogicalProject(a=[$0], b=[$1], c=[$2], a_sum=[AS($3, 'a_sum')])
:  +- LogicalAggregate(group=[{0, 1, 2}], TMP_0=[SUM($0)])
:     +- LogicalProject(a=[$0], b=[$1], c=[$2])
:        +- LogicalProject(a=[$0], b=[$1], c=[$2])
:           +- LogicalTableScan(table=[[builtin, default, t1]])
+- LogicalProject(a=[AS(1, 'a')], b=[$0], c=[$1], a_sum=[AS($2, 'a_sum')])
   +- LogicalAggregate(group=[{0, 1}], TMP_1=[SUM($2)])
      +- LogicalProject(b=[$1], c=[$2], a=[$0])
         +- LogicalProject(a=[$0], b=[$1], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t1]])

== Optimized Logical Plan ==
StreamExecSink(fields=[a, b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecUnion(all=[true], union=[a, b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])
   :- StreamExecCalc(select=[a, b, c, TMP_0 AS a_sum], updateAsRetraction=[false], accMode=[Acc])
   :  +- StreamExecGroupAggregate(groupBy=[a, b, c], select=[a, b, c, SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
   :     +- StreamExecExchange(distribution=[hash[a, b, c]], updateAsRetraction=[true], accMode=[Acc])
   :        +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
   +- StreamExecCalc(select=[CAST(1) AS a, b, c, TMP_1 AS a_sum], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecGroupAggregate(groupBy=[b, c], select=[b, c, SUM(a) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
         +- StreamExecExchange(distribution=[hash[b, c]], updateAsRetraction=[true], accMode=[Acc])
            +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : GroupAggregate(groupBy: (a, b, c), select: (a, b, c, SUM(a) AS TMP_0))
			ship_strategy : HASH

			 : Operator
				content : Calc(select: (a, b, c, TMP_0 AS a_sum))
				ship_strategy : FORWARD

				 : Operator
					content : GroupAggregate(groupBy: (b, c), select: (b, c, SUM(a) AS TMP_1))
					ship_strategy : HASH

					 : Operator
						content : Calc(select: (CAST(1) AS a, b, c, TMP_1 AS a_sum))
						ship_strategy : FORWARD

						 : Data Sink
							content : Sink: TestingUpsertTableSink(keys=())
							ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpdateAsRetractConsumedAtSinkBlock">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0], b=[$1], c=[$2], rank_num=[$3])
+- LogicalFilter(condition=[<=($3, 10)])
   +- LogicalProject(a=[$0], b=[$1], c=[$2], rank_num=[ROW_NUMBER() OVER (PARTITION BY $1 ORDER BY $2 DESC NULLS LAST ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])
      +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(a=[$0], b=[$1])
+- LogicalFilter(condition=[<($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[false], accMode=[Acc], reuse_id=[1])

StreamExecSink(fields=[a, b, c, rank_num], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecRank(rankFunction=[ROW_NUMBER], partitionBy=[b], orderBy=[c DESC], rankRange=[rankStart=1, rankEnd=10], strategy=[AppendFastRank], select=[*, rowNum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[a, b], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[a, b], where=[<(a, 6)], updateAsRetraction=[false], accMode=[Acc])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : AppendFastRank(orderBy: (c DESC), partitionBy: (b), *, rowNum, rankStart=1, rankEnd=10)
			ship_strategy : HASH

			 : Operator
				content : SinkConversion to Tuple2
				ship_strategy : FORWARD

				 : Operator
					content : Map
					ship_strategy : FORWARD

					 : Operator
						content : Calc(where: (a < 6), select: (a, b))
						ship_strategy : FORWARD

						 : Data Sink
							content : Sink: TestingRetractTableSink
							ship_strategy : FORWARD

							 : Data Sink
								content : Sink: TestingUpsertTableSink(keys=())
								ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpdateAsRetractConsumedAtSourceBlock">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0])
+- LogicalFilter(condition=[>($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(a=[$0], b=[$1])
+- LogicalFilter(condition=[<($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecRank(rankFunction=[ROW_NUMBER], partitionBy=[b], orderBy=[c DESC], rankRange=[rankStart=1, rankEnd=10], strategy=[AppendFastRank], select=[*, rowNum], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[false], accMode=[Acc])

StreamExecSink(fields=[a], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[a], where=[>(a, 6)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[a, b], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[a, b], where=[<(a, 6)], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b, c))
		ship_strategy : FORWARD

		 : Operator
			content : AppendFastRank(orderBy: (c DESC), partitionBy: (b), *, rowNum, rankStart=1, rankEnd=10)
			ship_strategy : HASH

			 : Operator
				content : Calc(where: (a > 6), select: (a))
				ship_strategy : FORWARD

				 : Operator
					content : SinkConversion to Tuple2
					ship_strategy : FORWARD

					 : Operator
						content : Map
						ship_strategy : FORWARD

						 : Operator
							content : Calc(where: (a < 6), select: (a, b))
							ship_strategy : FORWARD

							 : Data Sink
								content : Sink: TestingRetractTableSink
								ship_strategy : FORWARD

								 : Data Sink
									content : Sink: TestingUpsertTableSink(keys=())
									ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertAndUpsertSink">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(cnt=[$0], frequency=[AS($1, 'frequency')])
+- LogicalAggregate(group=[{0}], TMP_1=[COUNT($1)])
   +- LogicalProject(cnt=[$1], num=[$0])
      +- LogicalFilter(condition=[<($0, 4)])
         +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
            +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
               +- LogicalProject(num=[$1], id=[$0])
                  +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[cnt, frequency], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[cnt, TMP_1 AS frequency], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(num) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[AccRetract])
         +- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
            +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					 : Operator
						content : Calc(where: (num < 4), select: (num, cnt))
						ship_strategy : FORWARD

						 : Operator
							content : GroupAggregate(groupBy: (cnt), select: (cnt, COUNT_RETRACT(num) AS TMP_1))
							ship_strategy : HASH

							 : Operator
								content : Calc(select: (cnt, TMP_1 AS frequency))
								ship_strategy : FORWARD

								 : Operator
									content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=(0))
										ship_strategy : FORWARD

										 : Data Sink
											content : Sink: TestingUpsertTableSink(keys=())
											ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertAndUpsertSinkForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalAggregate(group=[{0}], frequency=[COUNT($1)])
+- LogicalProject(cnt=[$1], num=[$0])
   +- LogicalProject(num=[$0], cnt=[$1])
      +- LogicalFilter(condition=[<($0, 4)])
         +- LogicalTableScan(table=[[builtin, default, T1]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T1]])

== Optimized Logical Plan ==
StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[cnt, frequency], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(num) AS frequency], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecExchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
         +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				 : Operator
					content : Calc(where: (num < 4), select: (num, cnt))
					ship_strategy : FORWARD

					 : Operator
						content : GroupAggregate(groupBy: (cnt), select: (cnt, COUNT_RETRACT(num) AS frequency))
						ship_strategy : HASH

						 : Operator
							content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
							ship_strategy : FORWARD

							 : Data Sink
								content : Sink: TestingUpsertTableSink(keys=(0))
								ship_strategy : FORWARD

								 : Data Sink
									content : Sink: TestingUpsertTableSink(keys=())
									ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink0">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
+- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
   +- LogicalProject(num=[$1], id=[$0])
      +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					 : Data Sink
						content : Sink: TestingUpsertTableSink(keys=(0))
						ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalAggregate(group=[{0}], cnt=[COUNT($1)])
+- LogicalProject(num=[$1], id=[$0])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				 : Data Sink
					content : Sink: TestingUpsertTableSink(keys=(0))
					ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id1=[$2], num=[$3], text1=[$1])
+- LogicalJoin(condition=[=($2, $0)], joinType=[inner])
   :- LogicalProject(id3=[AS($0, 'id3')], text1=[AS($2, 'text1')])
   :  +- LogicalFilter(condition=[<($1, 5)])
   :     +- LogicalProject(id=[$0], num=[$1], text=[$2])
   :        +- LogicalFilter(condition=[>=($0, 0)])
   :           +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
   +- LogicalProject(id1=[$0], num=[$1], text2=[AS($3, 'text2')])
      +- LogicalJoin(condition=[=($0, $2)], joinType=[inner])
         :- LogicalProject(id1=[AS($0, 'id1')], num=[$1])
         :  +- LogicalFilter(condition=[<=($0, 10)])
         :     +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
         +- LogicalProject(id2=[AS($0, 'id2')], text=[$2])
            +- LogicalFilter(condition=[>=($1, 5)])
               +- LogicalProject(id=[$0], num=[$1], text=[$2])
                  +- LogicalFilter(condition=[>=($0, 0)])
                     +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecSink(fields=[id1, num, text1], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[id1, num, text1], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecJoin(where=[=(id1, id3)], join=[id3, text1, id1, num], joinType=[InnerJoin], updateAsRetraction=[false], accMode=[Acc])
      :- StreamExecExchange(distribution=[hash[id3]], updateAsRetraction=[true], accMode=[Acc])
      :  +- StreamExecCalc(select=[id AS id3, text AS text1], where=[AND(>=(id, 0), <(num, 5))], updateAsRetraction=[true], accMode=[Acc])
      :     +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
      +- StreamExecExchange(distribution=[hash[id1]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecCalc(select=[id1, num], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecJoin(where=[=(id1, id2)], join=[id1, num, id2], joinType=[InnerJoin], updateAsRetraction=[true], accMode=[Acc])
               :- StreamExecExchange(distribution=[hash[id1]], updateAsRetraction=[true], accMode=[Acc])
               :  +- StreamExecCalc(select=[id AS id1, num], where=[<=(id, 10)], updateAsRetraction=[true], accMode=[Acc])
               :     +- Reused(reference_id=[1])
               +- StreamExecExchange(distribution=[hash[id2]], updateAsRetraction=[true], accMode=[Acc])
                  +- StreamExecCalc(select=[id AS id2], where=[AND(>=(id, 0), >=(num, 5))], updateAsRetraction=[true], accMode=[Acc])
                     +- Reused(reference_id=[1])

== Physical Execution Plan ==
 : Data Source
	content : collect elements with CollectionInputFormat

	 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		 : Operator
			content : Calc(where: ((id >= 0) AND (num < 5)), select: (id AS id3, text AS text1))
			ship_strategy : FORWARD

			 : Operator
				content : Calc(where: (id <= 10), select: (id AS id1, num))
				ship_strategy : FORWARD

				 : Operator
					content : Calc(where: ((id >= 0) AND (num >= 5)), select: (id AS id2))
					ship_strategy : FORWARD

					 : Operator
						content : InnerJoin(where: (=(id1, id2)), join: (id1, num, id2))
						ship_strategy : HASH

						 : Operator
							content : Calc(select: (id1, num))
							ship_strategy : FORWARD

							 : Operator
								content : InnerJoin(where: (=(id1, id3)), join: (id3, text1, id1, num))
								ship_strategy : HASH

								 : Operator
									content : Calc(select: (id1, num, text1))
									ship_strategy : FORWARD

									 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=())
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
</Root>
