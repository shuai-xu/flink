<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="testFilter">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalFilter(condition=[=(MOD($0, 2), 0)])
+- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[a, b], where=[=(MOD(a, 2), 0)])
+- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]])

== Physical Execution Plan ==
Stage 279 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 280 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b))
		ship_strategy : FORWARD

		Stage 281 : Operator
			content : Calc(where: ((a MOD 2) = 0), select: (a, b))
			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiLevelViewForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[LIKE($2, '%hello%')])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T3]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T3]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%hello%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[3])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecUnion(all=[true], union=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :  +- Reused(reference_id=[1])
      +- StreamExecCalc(select=[num, id], where=[LIKE(text, '%world%')], updateAsRetraction=[true], accMode=[Acc])
         +- Reused(reference_id=[2])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[3])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[3])

== Physical Execution Plan ==
Stage 237 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 238 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 239 : Operator
			content : Calc(where: (text LIKE '%hello%'), select: (id, num, text))
			ship_strategy : FORWARD

			Stage 240 : Operator
				content : SinkConversion to Row
				ship_strategy : FORWARD

				Stage 242 : Operator
					content : Calc(select: (num, id))
					ship_strategy : FORWARD

					Stage 243 : Operator
						content : Calc(where: (text LIKE '%world%'), select: (num, id))
						ship_strategy : FORWARD

						Stage 246 : Operator
							content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
							ship_strategy : HASH

							Stage 247 : Operator
								content : Calc(where: (num < 4), select: (num, cnt))
								ship_strategy : FORWARD

								Stage 248 : Operator
									content : SinkConversion to Tuple2
									ship_strategy : FORWARD

									Stage 249 : Operator
										content : Map
										ship_strategy : FORWARD

										Stage 251 : Operator
											content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
											ship_strategy : FORWARD

											Stage 241 : Data Sink
												content : Sink: TestingAppendTableSink
												ship_strategy : FORWARD

												Stage 250 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

													Stage 252 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 91 : Data Source
	content : collect elements with CollectionInputFormat

Stage 92 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 93 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 94 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 95 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 96 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 99 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						Stage 100 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							Stage 103 : Operator
								content : GroupAggregate(select: (MIN(a) AS TMP_1))
								ship_strategy : GLOBAL

								Stage 104 : Operator
									content : Calc(select: (TMP_1 AS total_min))
									ship_strategy : FORWARD

									Stage 105 : Operator
										content : SinkConversion to Tuple2
										ship_strategy : FORWARD

										Stage 106 : Operator
											content : Map
											ship_strategy : FORWARD

											Stage 101 : Data Sink
												content : Sink: TestingUpsertTableSink(keys=())
												ship_strategy : FORWARD

												Stage 107 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 112 : Data Source
	content : collect elements with CollectionInputFormat

Stage 113 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 114 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 115 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 116 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 117 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 120 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						Stage 121 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							Stage 124 : Operator
								content : GroupAggregate(select: (MIN(a) AS TMP_1))
								ship_strategy : GLOBAL

								Stage 125 : Operator
									content : Calc(select: (TMP_1 AS total_min))
									ship_strategy : FORWARD

									Stage 126 : Operator
										content : SinkConversion to Tuple2
										ship_strategy : FORWARD

										Stage 127 : Operator
											content : Map
											ship_strategy : FORWARD

											Stage 122 : Data Sink
												content : Sink: TestingUpsertTableSink(keys=())
												ship_strategy : FORWARD

												Stage 128 : Data Sink
													content : Sink: TestingRetractTableSink
													ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion3">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(a=[$0])
+- LogicalUnion(all=[true])
   :- LogicalTableScan(table=[[builtin, default, t1]])
   +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])
:- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
:  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- Reused(reference_id=[2])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[a], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[2])

== Physical Execution Plan ==
Stage 133 : Data Source
	content : collect elements with CollectionInputFormat

Stage 134 : Data Source
	content : collect elements with CollectionInputFormat

Stage 135 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 136 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 137 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 138 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 139 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 141 : Operator
						content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
						ship_strategy : FORWARD

						Stage 142 : Operator
							content : Calc(select: (a))
							ship_strategy : FORWARD

							Stage 145 : Operator
								content : GroupAggregate(select: (SUM(a) AS TMP_0))
								ship_strategy : GLOBAL

								Stage 146 : Operator
									content : Calc(select: (TMP_0 AS total_sum))
									ship_strategy : FORWARD

									Stage 149 : Operator
										content : GroupAggregate(select: (MIN(a) AS TMP_1))
										ship_strategy : GLOBAL

										Stage 150 : Operator
											content : Calc(select: (TMP_1 AS total_min))
											ship_strategy : FORWARD

											Stage 151 : Operator
												content : SinkConversion to Tuple2
												ship_strategy : FORWARD

												Stage 152 : Operator
													content : Map
													ship_strategy : FORWARD

													Stage 147 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

														Stage 153 : Data Sink
															content : Sink: TestingRetractTableSink
															ship_strategy : FORWARD

															Stage 154 : Data Sink
																content : Sink: TestingUpsertTableSink(keys=())
																ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion4">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0])
+- LogicalUnion(all=[true])
   :- LogicalProject(a=[$0], c=[$2])
   :  +- LogicalTableScan(table=[[builtin, default, t1]])
   +- LogicalProject(d=[$0], f=[$2])
      +- LogicalTableScan(table=[[builtin, default, t2]])

LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[a], updateAsRetraction=[false], accMode=[Acc], reuse_id=[1])
:- StreamExecCalc(select=[a], updateAsRetraction=[false], accMode=[Acc])
:  +- StreamExecCalc(select=[a, c], updateAsRetraction=[true], accMode=[Acc])
:     +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecCalc(select=[d], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecCalc(select=[d, f], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[a], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- Reused(reference_id=[1])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[2])

StreamExecSink(fields=[total_min], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[2])

== Physical Execution Plan ==
Stage 161 : Data Source
	content : collect elements with CollectionInputFormat

Stage 162 : Data Source
	content : collect elements with CollectionInputFormat

Stage 163 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 164 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 165 : Operator
			content : Calc(select: (a, c))
			ship_strategy : FORWARD

			Stage 166 : Operator
				content : Calc(select: (a))
				ship_strategy : FORWARD

				Stage 167 : Operator
					content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
					ship_strategy : FORWARD

					Stage 168 : Operator
						content : Calc(select: (d, f))
						ship_strategy : FORWARD

						Stage 169 : Operator
							content : Calc(select: (d))
							ship_strategy : FORWARD

							Stage 171 : Operator
								content : SinkConversion to Row
								ship_strategy : FORWARD

								Stage 173 : Operator
									content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
									ship_strategy : FORWARD

									Stage 174 : Operator
										content : Calc(select: (a))
										ship_strategy : FORWARD

										Stage 177 : Operator
											content : GroupAggregate(select: (SUM(a) AS TMP_0))
											ship_strategy : GLOBAL

											Stage 178 : Operator
												content : Calc(select: (TMP_0 AS total_sum))
												ship_strategy : FORWARD

												Stage 179 : Operator
													content : SinkConversion to Tuple2
													ship_strategy : FORWARD

													Stage 180 : Operator
														content : Map
														ship_strategy : FORWARD

														Stage 183 : Operator
															content : GroupAggregate(select: (MIN(a) AS TMP_1))
															ship_strategy : GLOBAL

															Stage 184 : Operator
																content : Calc(select: (TMP_1 AS total_min))
																ship_strategy : FORWARD

																Stage 172 : Data Sink
																	content : Sink: TestingAppendTableSink
																	ship_strategy : FORWARD

																	Stage 181 : Data Sink
																		content : Sink: TestingRetractTableSink
																		ship_strategy : FORWARD

																		Stage 185 : Data Sink
																			content : Sink: TestingUpsertTableSink(keys=())
																			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiSinksSplitOnUnion5">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

LogicalProject(total_min=[AS($0, 'total_min')])
+- LogicalAggregate(group=[{}], TMP_1=[MIN($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalUnion(all=[true])
         :  :- LogicalProject(a=[$0], c=[$2])
         :  :  +- LogicalTableScan(table=[[builtin, default, t1]])
         :  +- LogicalProject(d=[$0], f=[$2])
         :     +- LogicalTableScan(table=[[builtin, default, t2]])
         +- LogicalProject(a=[$0], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t3]])

== Optimized Logical Plan ==
StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
   :  :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
   :  :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
   :  +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
   :     +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[total_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[total_min], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_1 AS total_min], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[MIN(a) AS TMP_1], updateAsRetraction=[true], accMode=[AccRetract])
      +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 192 : Data Source
	content : collect elements with CollectionInputFormat

Stage 193 : Data Source
	content : collect elements with CollectionInputFormat

Stage 194 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 195 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 196 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 197 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 198 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 200 : Operator
						content : SourceConversion(table:[builtin, default, t3], fields:(a, b, c))
						ship_strategy : FORWARD

						Stage 201 : Operator
							content : Calc(select: (a))
							ship_strategy : FORWARD

							Stage 204 : Operator
								content : GroupAggregate(select: (SUM(a) AS TMP_0))
								ship_strategy : GLOBAL

								Stage 205 : Operator
									content : Calc(select: (TMP_0 AS total_sum))
									ship_strategy : FORWARD

									Stage 208 : Operator
										content : GroupAggregate(select: (MIN(a) AS TMP_1))
										ship_strategy : GLOBAL

										Stage 209 : Operator
											content : Calc(select: (TMP_1 AS total_min))
											ship_strategy : FORWARD

											Stage 210 : Operator
												content : SinkConversion to Tuple2
												ship_strategy : FORWARD

												Stage 211 : Operator
													content : Map
													ship_strategy : FORWARD

													Stage 206 : Data Sink
														content : Sink: TestingUpsertTableSink(keys=())
														ship_strategy : FORWARD

														Stage 212 : Data Sink
															content : Sink: TestingRetractTableSink
															ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testRetractAndUpsertSink">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 255 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 256 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 257 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 259 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				Stage 260 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					Stage 261 : Operator
						content : Calc(where: (num < 4), select: (num, cnt))
						ship_strategy : FORWARD

						Stage 262 : Operator
							content : SinkConversion to Tuple2
							ship_strategy : FORWARD

							Stage 263 : Operator
								content : Map
								ship_strategy : FORWARD

								Stage 265 : Operator
									content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
									ship_strategy : FORWARD

									Stage 264 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

										Stage 266 : Data Sink
											content : Sink: TestingUpsertTableSink(keys=())
											ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testRetractAndUpsertSinkForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T1]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T1]])

== Optimized Logical Plan ==
StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 29 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 30 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 31 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 33 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				Stage 34 : Operator
					content : Calc(where: (num < 4), select: (num, cnt))
					ship_strategy : FORWARD

					Stage 35 : Operator
						content : SinkConversion to Tuple2
						ship_strategy : FORWARD

						Stage 36 : Operator
							content : Map
							ship_strategy : FORWARD

							Stage 38 : Operator
								content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
								ship_strategy : FORWARD

								Stage 37 : Data Sink
									content : Sink: TestingRetractTableSink
									ship_strategy : FORWARD

									Stage 39 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=())
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSharedUnionNode">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[LIKE($2, '%hello%')])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(id=[$0], num=[$1], text=[$2])
+- LogicalFilter(condition=[>=($1, 5)])
   +- LogicalTableScan(table=[[builtin, default, T3]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[<($0, 4)])
   +- LogicalTableScan(table=[[builtin, default, T4]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T4]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[2])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%hello%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[false], accMode=[Acc])
+- Reused(reference_id=[1])

StreamExecCalc(select=[id, num, text], where=[LIKE(text, '%world%')], updateAsRetraction=[true], accMode=[Acc], reuse_id=[3])
+- Reused(reference_id=[2])

StreamExecSink(fields=[id, num, text], updateAsRetraction=[true], accMode=[Acc])
+- StreamExecUnion(all=[true], union=[id, num, text], updateAsRetraction=[true], accMode=[Acc])
   :- StreamExecCalc(select=[id, num, text], where=[>=(num, 5)], updateAsRetraction=[true], accMode=[Acc])
   :  +- Reused(reference_id=[1])
   +- StreamExecCalc(select=[id, num, text], where=[>=(num, 5)], updateAsRetraction=[true], accMode=[Acc])
      +- Reused(reference_id=[3])

StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[4])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecUnion(all=[true], union=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      :  +- Reused(reference_id=[1])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- Reused(reference_id=[3])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[4])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[4])

== Physical Execution Plan ==
Stage 282 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 283 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 284 : Operator
			content : Calc(where: (text LIKE '%hello%'), select: (id, num, text))
			ship_strategy : FORWARD

			Stage 285 : Operator
				content : SinkConversion to Row
				ship_strategy : FORWARD

				Stage 287 : Operator
					content : Calc(where: (num >= 5), select: (id, num, text))
					ship_strategy : FORWARD

					Stage 288 : Operator
						content : Calc(where: (text LIKE '%world%'), select: (id, num, text))
						ship_strategy : FORWARD

						Stage 289 : Operator
							content : Calc(where: (num >= 5), select: (id, num, text))
							ship_strategy : FORWARD

							Stage 291 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								Stage 292 : Operator
									content : Map
									ship_strategy : FORWARD

									Stage 294 : Operator
										content : Calc(select: (num, id))
										ship_strategy : FORWARD

										Stage 295 : Operator
											content : Calc(select: (num, id))
											ship_strategy : FORWARD

											Stage 298 : Operator
												content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
												ship_strategy : HASH

												Stage 299 : Operator
													content : Calc(where: (num < 4), select: (num, cnt))
													ship_strategy : FORWARD

													Stage 300 : Operator
														content : SinkConversion to Tuple2
														ship_strategy : FORWARD

														Stage 301 : Operator
															content : Map
															ship_strategy : FORWARD

															Stage 303 : Operator
																content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
																ship_strategy : FORWARD

																Stage 286 : Data Sink
																	content : Sink: TestingAppendTableSink
																	ship_strategy : FORWARD

																	Stage 293 : Data Sink
																		content : Sink: TestingRetractTableSink
																		ship_strategy : FORWARD

																		Stage 302 : Data Sink
																			content : Sink: TestingRetractTableSink
																			ship_strategy : FORWARD

																			Stage 304 : Data Sink
																				content : Sink: TestingUpsertTableSink(keys=())
																				ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSingleSinkSplitOnUnion1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
            :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
            :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
               +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
Stage 307 : Data Source
	content : collect elements with CollectionInputFormat

Stage 308 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 309 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 310 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 311 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 312 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 315 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						Stage 316 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							Stage 317 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								Stage 318 : Operator
									content : Map
									ship_strategy : FORWARD

									Stage 319 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testSingleSinkSplitOnUnion2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(total_sum=[AS($0, 'total_sum')])
+- LogicalAggregate(group=[{}], TMP_0=[SUM($0)])
   +- LogicalProject(a=[$0])
      +- LogicalUnion(all=[true])
         :- LogicalProject(a=[$0], c=[$2])
         :  +- LogicalTableScan(table=[[builtin, default, t1]])
         +- LogicalProject(d=[$0], f=[$2])
            +- LogicalTableScan(table=[[builtin, default, t2]])

== Optimized Logical Plan ==
StreamExecSink(fields=[total_sum], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[TMP_0 AS total_sum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecGroupAggregate(select=[SUM(a) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecExchange(distribution=[single], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecUnion(all=[true], union=[a], updateAsRetraction=[true], accMode=[Acc])
            :- StreamExecCalc(select=[a], updateAsRetraction=[true], accMode=[Acc])
            :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecCalc(select=[d], updateAsRetraction=[true], accMode=[Acc])
               +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
Stage 322 : Data Source
	content : collect elements with CollectionInputFormat

Stage 323 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 324 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 325 : Operator
			content : Calc(select: (a))
			ship_strategy : FORWARD

			Stage 326 : Operator
				content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
				ship_strategy : FORWARD

				Stage 327 : Operator
					content : Calc(select: (d))
					ship_strategy : FORWARD

					Stage 330 : Operator
						content : GroupAggregate(select: (SUM(a) AS TMP_0))
						ship_strategy : GLOBAL

						Stage 331 : Operator
							content : Calc(select: (TMP_0 AS total_sum))
							ship_strategy : FORWARD

							Stage 332 : Operator
								content : SinkConversion to Tuple2
								ship_strategy : FORWARD

								Stage 333 : Operator
									content : Map
									ship_strategy : FORWARD

									Stage 334 : Data Sink
										content : Sink: TestingRetractTableSink
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUdtf">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalCorrelate(correlation=[$cor2], joinType=[inner], requiredColumns=[{}])
:- LogicalFilter(condition=[=($0, $6)])
:  +- LogicalJoin(condition=[true], joinType=[inner])
:     :- LogicalFilter(condition=[=($1, $4)])
:     :  +- LogicalJoin(condition=[true], joinType=[inner])
:     :     :- LogicalTableScan(table=[[builtin, default, t1]])
:     :     +- LogicalTableScan(table=[[builtin, default, t2]])
:     +- LogicalTableScan(table=[[builtin, default, t3]])
+- LogicalTableFunctionScan(invocation=[org$apache$flink$table$util$TableFunc1$4cf19b69e9ec9920db1afce973dac2eb($5)], rowType=[RecordType(VARCHAR(65536) f1)], elementType=[class [Ljava.lang.Object;])

== Optimized Logical Plan ==
StreamExecSink(fields=[a, b, c, d, e, f, i, j, k, l, m, f1], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCorrelate(invocation=[org$apache$flink$table$util$TableFunc1$4cf19b69e9ec9920db1afce973dac2eb($5)], correlate=[table(TableFunc1(f))], select=[a,b,c,d,e,f,i,j,k,l,m,f1], rowType=[RecordType(INTEGER a, BIGINT b, VARCHAR(65536) c, INTEGER d, BIGINT e, VARCHAR(65536) f, INTEGER i, BIGINT j, INTEGER k, VARCHAR(65536) l, BIGINT m, VARCHAR(65536) f1)], joinType=[INNER], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecJoin(where=[=(a, i)], join=[a, b, c, d, e, f, i, j, k, l, m], joinType=[InnerJoin], updateAsRetraction=[false], accMode=[Acc])
      :- StreamExecExchange(distribution=[hash[a]], updateAsRetraction=[true], accMode=[Acc])
      :  +- StreamExecJoin(where=[=(b, e)], join=[a, b, c, d, e, f], joinType=[InnerJoin], updateAsRetraction=[true], accMode=[Acc])
      :     :- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[true], accMode=[Acc])
      :     :  +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc])
      :     +- StreamExecExchange(distribution=[hash[e]], updateAsRetraction=[true], accMode=[Acc])
      :        +- StreamExecDataStreamScan(table=[[builtin, default, t2]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[i]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, t3]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
Stage 219 : Data Source
	content : collect elements with CollectionInputFormat

Stage 220 : Data Source
	content : collect elements with CollectionInputFormat

Stage 221 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 222 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 224 : Operator
			content : SourceConversion(table:[builtin, default, t2], fields:(d, e, f))
			ship_strategy : FORWARD

			Stage 226 : Operator
				content : InnerJoin(where: (=(b, e)), join: (a, b, c, d, e, f))
				ship_strategy : HASH

				Stage 228 : Operator
					content : SourceConversion(table:[builtin, default, t3], fields:(i, j, k, l, m))
					ship_strategy : FORWARD

					Stage 230 : Operator
						content : InnerJoin(where: (=(a, i)), join: (a, b, c, d, e, f, i, j, k, l, m))
						ship_strategy : HASH

						Stage 231 : Operator
							content : correlate: table(TableFunc1(f)), select: a,b,c,d,e,f,i,j,k,l,m,f1
							ship_strategy : FORWARD

							Stage 232 : Data Sink
								content : Sink: csv sink: file
								ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnion">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalUnion(all=[true])
:- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
+- LogicalTableScan(table=[[builtin, default, _DataStreamTable_1]])

== Optimized Logical Plan ==
StreamExecUnion(all=[true], union=[count, word])
:- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]])
+- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_1]])

== Physical Execution Plan ==
Stage 86 : Data Source
	content : collect elements with CollectionInputFormat

Stage 87 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 88 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(count, word))
		ship_strategy : FORWARD

		Stage 89 : Operator
			content : SourceConversion(table:[builtin, default, _DataStreamTable_1], fields:(count, word))
			ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnionAggWithDifferentGroupings">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalUnion(all=[true])
:- LogicalProject(a=[$0], b=[$1], c=[$2], a_sum=[AS($3, 'a_sum')])
:  +- LogicalAggregate(group=[{0, 1, 2}], TMP_0=[SUM($0)])
:     +- LogicalProject(a=[$0], b=[$1], c=[$2])
:        +- LogicalProject(a=[$0], b=[$1], c=[$2])
:           +- LogicalTableScan(table=[[builtin, default, t1]])
+- LogicalProject(a=[AS(1, 'a')], b=[$0], c=[$1], a_sum=[AS($2, 'a_sum')])
   +- LogicalAggregate(group=[{0, 1}], TMP_1=[SUM($2)])
      +- LogicalProject(b=[$1], c=[$2], a=[$0])
         +- LogicalProject(a=[$0], b=[$1], c=[$2])
            +- LogicalTableScan(table=[[builtin, default, t1]])

== Optimized Logical Plan ==
StreamExecSink(fields=[a, b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecUnion(all=[true], union=[a, b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])
   :- StreamExecCalc(select=[a, b, c, TMP_0 AS a_sum], updateAsRetraction=[false], accMode=[Acc])
   :  +- StreamExecGroupAggregate(groupBy=[a, b, c], select=[a, b, c, SUM(a) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
   :     +- StreamExecExchange(distribution=[hash[a, b, c]], updateAsRetraction=[true], accMode=[Acc])
   :        +- StreamExecDataStreamScan(table=[[builtin, default, t1]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
   +- StreamExecCalc(select=[CAST(1) AS a, b, c, TMP_1 AS a_sum], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecGroupAggregate(groupBy=[b, c], select=[b, c, SUM(a) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
         +- StreamExecExchange(distribution=[hash[b, c]], updateAsRetraction=[true], accMode=[Acc])
            +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 74 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 75 : Operator
		content : SourceConversion(table:[builtin, default, t1], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 77 : Operator
			content : GroupAggregate(groupBy: (a, b, c), select: (a, b, c, SUM(a) AS TMP_0))
			ship_strategy : HASH

			Stage 78 : Operator
				content : Calc(select: (a, b, c, TMP_0 AS a_sum))
				ship_strategy : FORWARD

				Stage 80 : Operator
					content : GroupAggregate(groupBy: (b, c), select: (b, c, SUM(a) AS TMP_1))
					ship_strategy : HASH

					Stage 81 : Operator
						content : Calc(select: (CAST(1) AS a, b, c, TMP_1 AS a_sum))
						ship_strategy : FORWARD

						Stage 83 : Data Sink
							content : Sink: TestingUpsertTableSink(keys=())
							ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpdateAsRetractConsumedAtSinkBlock">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0], b=[$1], c=[$2], rank_num=[$3])
+- LogicalFilter(condition=[<=($3, 10)])
   +- LogicalProject(a=[$0], b=[$1], c=[$2], rank_num=[ROW_NUMBER() OVER (PARTITION BY $1 ORDER BY $2 DESC NULLS LAST ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])
      +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(a=[$0], b=[$1])
+- LogicalFilter(condition=[<($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[false], accMode=[Acc], reuse_id=[1])

StreamExecSink(fields=[a, b, c, rank_num], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecRank(rankFunction=[ROW_NUMBER], partitionBy=[b], orderBy=[c DESC], rankRange=[rankStart=1, rankEnd=10], strategy=[AppendFastRank], select=[*, rowNum], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[false], accMode=[Acc])
      +- Reused(reference_id=[1])

StreamExecSink(fields=[a, b], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[a, b], where=[<(a, 6)], updateAsRetraction=[false], accMode=[Acc])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 337 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 338 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 340 : Operator
			content : AppendFastRank(orderBy: (c DESC), partitionBy: (b), *, rowNum, rankStart=1, rankEnd=10)
			ship_strategy : HASH

			Stage 341 : Operator
				content : SinkConversion to Tuple2
				ship_strategy : FORWARD

				Stage 342 : Operator
					content : Map
					ship_strategy : FORWARD

					Stage 344 : Operator
						content : Calc(where: (a < 6), select: (a, b))
						ship_strategy : FORWARD

						Stage 343 : Data Sink
							content : Sink: TestingRetractTableSink
							ship_strategy : FORWARD

							Stage 345 : Data Sink
								content : Sink: TestingUpsertTableSink(keys=())
								ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpdateAsRetractConsumedAtSourceBlock">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(a=[$0])
+- LogicalFilter(condition=[>($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

LogicalProject(a=[$0], b=[$1])
+- LogicalFilter(condition=[<($0, 6)])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecRank(rankFunction=[ROW_NUMBER], partitionBy=[b], orderBy=[c DESC], rankRange=[rankStart=1, rankEnd=10], strategy=[AppendFastRank], select=[*, rowNum], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[b]], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[false], accMode=[Acc])

StreamExecSink(fields=[a], updateAsRetraction=[true], accMode=[AccRetract])
+- StreamExecCalc(select=[a], where=[>(a, 6)], updateAsRetraction=[true], accMode=[AccRetract])
   +- Reused(reference_id=[1])

StreamExecSink(fields=[a, b], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[a, b], where=[<(a, 6)], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 268 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 269 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(a, b, c))
		ship_strategy : FORWARD

		Stage 271 : Operator
			content : AppendFastRank(orderBy: (c DESC), partitionBy: (b), *, rowNum, rankStart=1, rankEnd=10)
			ship_strategy : HASH

			Stage 272 : Operator
				content : Calc(where: (a > 6), select: (a))
				ship_strategy : FORWARD

				Stage 273 : Operator
					content : SinkConversion to Tuple2
					ship_strategy : FORWARD

					Stage 274 : Operator
						content : Map
						ship_strategy : FORWARD

						Stage 276 : Operator
							content : Calc(where: (a < 6), select: (a, b))
							ship_strategy : FORWARD

							Stage 275 : Data Sink
								content : Sink: TestingRetractTableSink
								ship_strategy : FORWARD

								Stage 277 : Data Sink
									content : Sink: TestingUpsertTableSink(keys=())
									ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertAndUpsertSink">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(cnt=[$0], frequency=[AS($1, 'frequency')])
+- LogicalAggregate(group=[{0}], TMP_1=[COUNT($1)])
   +- LogicalProject(cnt=[$1], num=[$0])
      +- LogicalFilter(condition=[<($0, 4)])
         +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
            +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
               +- LogicalProject(num=[$1], id=[$0])
                  +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
      +- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
         +- LogicalProject(num=[$1], id=[$0])
            +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[true], accMode=[AccRetract])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[cnt, frequency], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[cnt, TMP_1 AS frequency], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(num) AS TMP_1], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[AccRetract])
         +- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
            +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 1 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 2 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 3 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 5 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				Stage 6 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					Stage 7 : Operator
						content : Calc(where: (num < 4), select: (num, cnt))
						ship_strategy : FORWARD

						Stage 9 : Operator
							content : GroupAggregate(groupBy: (cnt), select: (cnt, COUNT_RETRACT(num) AS TMP_1))
							ship_strategy : HASH

							Stage 10 : Operator
								content : Calc(select: (cnt, TMP_1 AS frequency))
								ship_strategy : FORWARD

								Stage 12 : Operator
									content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
									ship_strategy : FORWARD

									Stage 11 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=(0))
										ship_strategy : FORWARD

										Stage 13 : Data Sink
											content : Sink: TestingUpsertTableSink(keys=())
											ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertAndUpsertSinkForSQL">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalAggregate(group=[{0}], frequency=[COUNT($1)])
+- LogicalProject(cnt=[$1], num=[$0])
   +- LogicalProject(num=[$0], cnt=[$1])
      +- LogicalFilter(condition=[<($0, 4)])
         +- LogicalTableScan(table=[[builtin, default, T1]])

LogicalProject(num=[$0], cnt=[$1])
+- LogicalFilter(condition=[AND(>=($0, 4), <($0, 6))])
   +- LogicalTableScan(table=[[builtin, default, T1]])

== Optimized Logical Plan ==
StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[true], accMode=[AccRetract], reuse_id=[1])
+- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
   +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

StreamExecSink(fields=[cnt, frequency], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(num) AS frequency], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecExchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[AccRetract])
      +- StreamExecCalc(select=[num, cnt], where=[<(num, 4)], updateAsRetraction=[true], accMode=[AccRetract])
         +- Reused(reference_id=[1])

StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[AccRetract])
+- StreamExecCalc(select=[num, cnt], where=[AND(>=(num, 4), <(num, 6))], updateAsRetraction=[false], accMode=[AccRetract])
   +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 16 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 17 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 18 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 20 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				Stage 21 : Operator
					content : Calc(where: (num < 4), select: (num, cnt))
					ship_strategy : FORWARD

					Stage 23 : Operator
						content : GroupAggregate(groupBy: (cnt), select: (cnt, COUNT_RETRACT(num) AS frequency))
						ship_strategy : HASH

						Stage 25 : Operator
							content : Calc(where: ((num >= 4) AND (num < 6)), select: (num, cnt))
							ship_strategy : FORWARD

							Stage 24 : Data Sink
								content : Sink: TestingUpsertTableSink(keys=(0))
								ship_strategy : FORWARD

								Stage 26 : Data Sink
									content : Sink: TestingUpsertTableSink(keys=())
									ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink0">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(num=[$0], cnt=[AS($1, 'cnt')])
+- LogicalAggregate(group=[{0}], TMP_0=[COUNT($1)])
   +- LogicalProject(num=[$1], id=[$0])
      +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[num, TMP_0 AS cnt], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS TMP_0], updateAsRetraction=[false], accMode=[Acc])
      +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
Stage 41 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 42 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 43 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 45 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS TMP_0))
				ship_strategy : HASH

				Stage 46 : Operator
					content : Calc(select: (num, TMP_0 AS cnt))
					ship_strategy : FORWARD

					Stage 47 : Data Sink
						content : Sink: TestingUpsertTableSink(keys=(0))
						ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink1">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalAggregate(group=[{0}], cnt=[COUNT($1)])
+- LogicalProject(num=[$1], id=[$0])
   +- LogicalTableScan(table=[[builtin, default, T]])

== Optimized Logical Plan ==
StreamExecSink(fields=[num, cnt], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecGroupAggregate(groupBy=[num], select=[num, COUNT(id) AS cnt], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecExchange(distribution=[hash[num]], updateAsRetraction=[true], accMode=[Acc])
      +- StreamExecCalc(select=[num, id], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecDataStreamScan(table=[[builtin, default, T]], updateAsRetraction=[true], accMode=[Acc])

== Physical Execution Plan ==
Stage 49 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 50 : Operator
		content : SourceConversion(table:[builtin, default, T], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 51 : Operator
			content : Calc(select: (num, id))
			ship_strategy : FORWARD

			Stage 53 : Operator
				content : GroupAggregate(groupBy: (num), select: (num, COUNT(id) AS cnt))
				ship_strategy : HASH

				Stage 54 : Data Sink
					content : Sink: TestingUpsertTableSink(keys=(0))
					ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
  <TestCase name="testUpsertSink2">
    <Resource name="explain">
      <![CDATA[== Abstract Syntax Tree ==
LogicalProject(id1=[$2], num=[$3], text1=[$1])
+- LogicalJoin(condition=[=($2, $0)], joinType=[inner])
   :- LogicalProject(id3=[AS($0, 'id3')], text1=[AS($2, 'text1')])
   :  +- LogicalFilter(condition=[<($1, 5)])
   :     +- LogicalProject(id=[$0], num=[$1], text=[$2])
   :        +- LogicalFilter(condition=[>=($0, 0)])
   :           +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
   +- LogicalProject(id1=[$0], num=[$1], text2=[AS($3, 'text2')])
      +- LogicalJoin(condition=[=($0, $2)], joinType=[inner])
         :- LogicalProject(id1=[AS($0, 'id1')], num=[$1])
         :  +- LogicalFilter(condition=[<=($0, 10)])
         :     +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])
         +- LogicalProject(id2=[AS($0, 'id2')], text=[$2])
            +- LogicalFilter(condition=[>=($1, 5)])
               +- LogicalProject(id=[$0], num=[$1], text=[$2])
                  +- LogicalFilter(condition=[>=($0, 0)])
                     +- LogicalTableScan(table=[[builtin, default, _DataStreamTable_0]])

== Optimized Logical Plan ==
StreamExecSink(fields=[id1, num, text1], updateAsRetraction=[false], accMode=[Acc])
+- StreamExecCalc(select=[id1, num, text1], updateAsRetraction=[false], accMode=[Acc])
   +- StreamExecJoin(where=[=(id1, id3)], join=[id3, text1, id1, num], joinType=[InnerJoin], updateAsRetraction=[false], accMode=[Acc])
      :- StreamExecExchange(distribution=[hash[id3]], updateAsRetraction=[true], accMode=[Acc])
      :  +- StreamExecCalc(select=[id AS id3, text AS text1], where=[AND(>=(id, 0), <(num, 5))], updateAsRetraction=[true], accMode=[Acc])
      :     +- StreamExecDataStreamScan(table=[[builtin, default, _DataStreamTable_0]], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])
      +- StreamExecExchange(distribution=[hash[id1]], updateAsRetraction=[true], accMode=[Acc])
         +- StreamExecCalc(select=[id1, num], updateAsRetraction=[true], accMode=[Acc])
            +- StreamExecJoin(where=[=(id1, id2)], join=[id1, num, id2], joinType=[InnerJoin], updateAsRetraction=[true], accMode=[Acc])
               :- StreamExecExchange(distribution=[hash[id1]], updateAsRetraction=[true], accMode=[Acc])
               :  +- StreamExecCalc(select=[id AS id1, num], where=[<=(id, 10)], updateAsRetraction=[true], accMode=[Acc])
               :     +- Reused(reference_id=[1])
               +- StreamExecExchange(distribution=[hash[id2]], updateAsRetraction=[true], accMode=[Acc])
                  +- StreamExecCalc(select=[id AS id2], where=[AND(>=(id, 0), >=(num, 5))], updateAsRetraction=[true], accMode=[Acc])
                     +- Reused(reference_id=[1])

== Physical Execution Plan ==
Stage 56 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 57 : Operator
		content : SourceConversion(table:[builtin, default, _DataStreamTable_0], fields:(id, num, text))
		ship_strategy : FORWARD

		Stage 58 : Operator
			content : Calc(where: ((id >= 0) AND (num < 5)), select: (id AS id3, text AS text1))
			ship_strategy : FORWARD

			Stage 60 : Operator
				content : Calc(where: (id <= 10), select: (id AS id1, num))
				ship_strategy : FORWARD

				Stage 62 : Operator
					content : Calc(where: ((id >= 0) AND (num >= 5)), select: (id AS id2))
					ship_strategy : FORWARD

					Stage 64 : Operator
						content : InnerJoin(where: (=(id1, id2)), join: (id1, num, id2))
						ship_strategy : HASH

						Stage 65 : Operator
							content : Calc(select: (id1, num))
							ship_strategy : FORWARD

							Stage 67 : Operator
								content : InnerJoin(where: (=(id1, id3)), join: (id3, text1, id1, num))
								ship_strategy : HASH

								Stage 68 : Operator
									content : Calc(select: (id1, num, text1))
									ship_strategy : FORWARD

									Stage 69 : Data Sink
										content : Sink: TestingUpsertTableSink(keys=())
										ship_strategy : FORWARD

]]>
    </Resource>
  </TestCase>
</Root>
